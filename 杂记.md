1. 操作系统调度算法
    1. 先来先服务（FCFS）：
       
          - 这是最简单的调度算法之一，遵循“先到先服务”的原则。进程按照它们到达系统的顺序被调度执行。
          - 优点：实现简单，易于理解和管理。
          - 缺点：可能会导致长任务的进程无限期地占用CPU，导致短任务进程等待时间过长，从而导致饥饿现象。此外，FCFS不能很好地响应突发的任务。
  
    2. 短作业优先（SJF - Shortest Job First）：
  
          - 该算法会选择执行时间最短的进程优先执行。
          - 分为非抢占式短作业优先（Non-Preemptive SJF）和抢占式短作业优先（Shortest Remaining Time First, SRTF）。
              - 非抢占式SJF一旦选择一个进程开始执行，就不会被其他新到达的进程抢占，直到该进程完成。
              - 抢占式SRTF则允许在新到达的进程剩余运行时间比当前正在执行的进程更短时，进行进程切换。
          - 优点：可以减少短进程的平均等待时间。
          - 缺点：长进程可能会被短进程反复抢占，导致它们等待时间增加，也可能发生饥饿现象。
            
    3. 优先级调度（Priority Scheduling）：
  
          - 根据进程的优先级来决定调度顺序，优先级高的进程优先执行。
          - 可以是非抢占式的也可以是抢占式的。
              - 非抢占式优先级调度一旦选择一个进程开始执行，就不会被其他进程抢占，直到它完成。
              - 抢占式优先级调度允许在新到达的进程优先级更高时，进行进程切换。
          - 优点：能够快速响应高优先级的任务，灵活性高。
          - 缺点：如果不小心，可能会导致优先级反转和饥饿现象。
            
    4. 高响应比优先（HRRN - Highest Response Ratio Next）：
  
          - 该算法是SJF和FCFS的结合体。它在每次调度时，计算每个进程的响应比，响应比高的进程优先执行。
          - 响应比计算公式为：响应比 = (等待时间 + 要求的服务时间) / 要求的服务时间。
          - 优点：能够平衡短进程和长进程的需求，减少饥饿现象。
          - 缺点：实现相对复杂。
  
    5. 时间片轮转（RR - Round Robin）：
  
          - 该算法将CPU时间分成固定的时间片，并按照轮转的方式为每个进程分配一个时间片进行执行。
          - 如果在时间片内进程未能完成，则将进程放到队列的末尾，等待下一次分配时间片。
          - 优点：每个进程都有机会被执行，能够很好地响应交互式任务，避免饥饿现象。
          - 缺点：如果时间片设置不当，可能会导致进程频繁切换，增加系统开销。
  
    6. 多级反馈队列（MLFQ - Multi-Level Feedback Queue）：
  
          - 该算法将进程分为多个优先级队列，并根据进程的执行情况在不同的队列之间迁移。
          - 通常，新到达的进程会被放到最低优先级的队列，每次执行完一个时间片后，如果进程仍在运行，则会被移动到一个更低优先级的队列。如果进程在执行后完成，则不再被调度。如果进程长期占用CPU，则优先级降低。
          - 优点：灵活性高，能够同时满足不同类型的进程需求。
          - 缺点：实现复杂，需要对进程进行精确的监控和调整。
2. http协议状态码：
   - 301：moved permanently，表示资源被永久转移到其他URL。
   - 200：ok，表示请求成功，服务器返回请求的资源。
   - 502：bad gateway，表示服务器作为网关/代理，从上游服务器收到了无效的响应。
   - 304：not modified，表客户端缓存资源已是最新，无需重新发送。
3. session & cookie
   - 客户端是cookie，服务端是session
   - cookie更灵活，session更安全。
   - http是没有状态的，记不住进行数据传输的对象，因此需要cookie记录用户状态。cookie是在http头中写入cookie信息来控制用户状态的机制。
     - 用户第一次登录时，服务端会创建一个id来唯一识别此用户，这个id叫session id，该id会被存入服务器内存（如Redis）或数据库中。
     - 创建完后，会把id塞到set-cookie的响应头里，告诉浏览器要存储这个cookie，此cookie中不止有session id，还有一些别的值。
     - 浏览器把cookie存到内存后，以后每次http请求都会带上这个cookie。
     - 服务端会把送来的cookie中的session id和后台存的id对比，若一致则正常返回数据，否则返回登录页（类似每次访问网站的招聘页面）
     - 服务器把session id存入缓存后，session id可以作为一个key值，下面存一些用户数据，例如用户id、名字、姓名、城市...通过session id就能拿到用户id，知道是哪个用户
   - cookie大小一般限制为4KB
   - cookie重要属性：
     - expires:设置cookie有效期
     - domain:设置cookie所属域名，设置可以设置为二级、三级域名下，这样好几个在同一域名下的web服务器的登录态（cookie）都是共享的。
     - httponly:禁止JS读取cookie，确保cookie安全，防止被XSS攻击。
     - secure:因为http明文传输不安全，设置secure:true，表示仅在https连接下传输cookie。
    - cookie和session id是一一对应的关系。cookie和session两者相互协作
4. epoll & select
    - select 是一种轮询机制，它会定期检查文件描述符的状态，这可能导致较高的 CPU 使用率，尤其是在监视大量文件描述符时。
    - epoll 是一种事件通知机制，它利用内核的事件通知机制来高效地监视文件描述符。epoll 只在有 I/O 事件发生时才会通知用户空间，从而提高效率。
    - select 受到单个进程可监视的文件描述符数量的限制。
    - epoll 和 select 都可以监视多个 I/O 事件。
    - epoll 支持水平触发和边沿触发两种模式。
5. B树 & B+树
   - B树不支持顺序检索，因为叶子结点间没有指针。
   - B 树和 B+ 树都可以有效地支持随机检索。它们通过多层结构和平衡性，使得查找、插入和删除操作的时间复杂度为 O（log(n)）。
   - B 树和 B+ 树广泛用于文件系统和数据库的索引结构，因为它们能够有效地支持大量的查找、插入和删除操作，并且具有良好的平衡性。
   - B 树和 B+ 树都是平衡的多分树。它们通过确保所有叶子节点位于同一层来保持平衡。
6. 变量存储区域
    - 栈区(stack)
        - 用于存储函数调用时的局部变量、函数参数、返回地址等信息
        - 栈是自动管理的，当函数调用结束时，局部变量会被**自动释放**
    - 堆区(heap)
        - 用于存储动态分配的内存，如使用 malloc、calloc、new 等操作分配的内存。
        - 程序员手动管理堆区，需手动分配和释放。
    - 代码区
        - 只存储程序的机器指令
        - 只读，确保指令不会被意外修改
    - 全局区
        - 存储全局变量和静态变量
        - 静态分配的，其大小在程序编译时确定，并且在整个程序运行期间都存在
          - 静态变量：无论是全局静态变量还是函数内部的静态变量，都存储在数据段中。
7. linux系统中无法被捕获的信号：sigkill
8. TIME_WAIT状态
   - time_wait出现在主动关闭的一方，close_wait出现在被动关闭的一方。
     - 在完成四次挥手的关闭过程后，主动关闭的一方会进入time_wait状态，而被动关闭一方进入close_wait状态
   - TIME_WAIT 状态到CLOSE状态的超时设置为 2 倍的 MSL（Maximum Segment Lifetime）。MSL 通常是 2 分钟，因此 TIME_WAIT 状态的超时通常为 4 分钟
   - TIME_WAIT 状态确保有足够的时间让对端收到最后一个 ACK 消息。这是为了防止在新的连接中出现序列号冲突。
   - TIME_WAIT 状态的超时设置确保有足够的时间让当前连接的段在新的连接中不会被误认为是旧连接的段，从而避免序列号冲突。
