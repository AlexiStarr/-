1. 操作系统调度算法
    1. 先来先服务（FCFS）：
       
          - 这是最简单的调度算法之一，遵循“先到先服务”的原则。进程按照它们到达系统的顺序被调度执行。
          - 优点：实现简单，易于理解和管理。
          - 缺点：可能会导致长任务的进程无限期地占用CPU，导致短任务进程等待时间过长，从而导致饥饿现象。此外，FCFS不能很好地响应突发的任务。
  
    2. 短作业优先（SJF - Shortest Job First）：
  
          - 该算法会选择执行时间最短的进程优先执行。
          - 分为非抢占式短作业优先（Non-Preemptive SJF）和抢占式短作业优先（Shortest Remaining Time First, SRTF）。
              - 非抢占式SJF一旦选择一个进程开始执行，就不会被其他新到达的进程抢占，直到该进程完成。
              - 抢占式SRTF则允许在新到达的进程剩余运行时间比当前正在执行的进程更短时，进行进程切换。
          - 优点：可以减少短进程的平均等待时间。
          - 缺点：长进程可能会被短进程反复抢占，导致它们等待时间增加，也可能发生饥饿现象。
            
    3. 优先级调度（Priority Scheduling）：
  
          - 根据进程的优先级来决定调度顺序，优先级高的进程优先执行。
          - 可以是非抢占式的也可以是抢占式的。
              - 非抢占式优先级调度一旦选择一个进程开始执行，就不会被其他进程抢占，直到它完成。
              - 抢占式优先级调度允许在新到达的进程优先级更高时，进行进程切换。
          - 优点：能够快速响应高优先级的任务，灵活性高。
          - 缺点：如果不小心，可能会导致优先级反转和饥饿现象。
            
    4. 高响应比优先（HRRN - Highest Response Ratio Next）：
  
          - 该算法是SJF和FCFS的结合体。它在每次调度时，计算每个进程的响应比，响应比高的进程优先执行。
          - 响应比计算公式为：响应比 = (等待时间 + 要求的服务时间) / 要求的服务时间。
          - 优点：能够平衡短进程和长进程的需求，减少饥饿现象。
          - 缺点：实现相对复杂。
  
    5. 时间片轮转（RR - Round Robin）：
  
          - 该算法将CPU时间分成固定的时间片，并按照轮转的方式为每个进程分配一个时间片进行执行。
          - 如果在时间片内进程未能完成，则将进程放到队列的末尾，等待下一次分配时间片。
          - 优点：每个进程都有机会被执行，能够很好地响应交互式任务，避免饥饿现象。
          - 缺点：如果时间片设置不当，可能会导致进程频繁切换，增加系统开销。
  
    6. 多级反馈队列（MLFQ - Multi-Level Feedback Queue）：
  
          - 该算法将进程分为多个优先级队列，并根据进程的执行情况在不同的队列之间迁移。
          - 通常，新到达的进程会被放到最低优先级的队列，每次执行完一个时间片后，如果进程仍在运行，则会被移动到一个更低优先级的队列。如果进程在执行后完成，则不再被调度。如果进程长期占用CPU，则优先级降低。
          - 优点：灵活性高，能够同时满足不同类型的进程需求。
          - 缺点：实现复杂，需要对进程进行精确的监控和调整。
2. http协议状态码：
   - 301：moved permanently，表示资源被永久转移到其他URL。
   - 200：ok，表示请求成功，服务器返回请求的资源。
   - 502：bad gateway，表示服务器作为网关/代理，从上游服务器收到了无效的响应。
   - 304：not modified，表客户端缓存资源已是最新，无需重新发送。
3. session & cookie
   - 客户端是cookie，服务端是session
   - cookie更灵活，session更安全。
   - http是没有状态的，记不住进行数据传输的对象，因此需要cookie记录用户状态。cookie是在http头中写入cookie信息来控制用户状态的机制。
     - 用户第一次登录时，服务端会创建一个id来唯一识别此用户，这个id叫session id，该id会被存入服务器内存（如Redis）或数据库中。
     - 创建完后，会把id塞到set-cookie的响应头里，告诉浏览器要存储这个cookie，此cookie中不止有session id，还有一些别的值。
     - 浏览器把cookie存到内存后，以后每次http请求都会带上这个cookie。
     - 服务端会把送来的cookie中的session id和后台存的id对比，若一致则正常返回数据，否则返回登录页（类似每次访问网站的招聘页面）
     - 服务器把session id存入缓存后，session id可以作为一个key值，下面存一些用户数据，例如用户id、名字、姓名、城市...通过session id就能拿到用户id，知道是哪个用户
   - cookie大小一般限制为4KB
   - cookie重要属性：
     - expires:设置cookie有效期
     - domain:设置cookie所属域名，设置可以设置为二级、三级域名下，这样好几个在同一域名下的web服务器的登录态（cookie）都是共享的。
     - httponly:禁止JS读取cookie，确保cookie安全，防止被XSS攻击。
     - secure:因为http明文传输不安全，设置secure:true，表示仅在https连接下传输cookie。
    - cookie和session id是一一对应的关系。cookie和session两者相互协作
